---
description: Pradeep Opticals - Frontend code guidelines
globs: Code Guidelines for the fronted
alwaysApply: true
---

# Frontend Architecture Ruleset

## Architecture Flow
All user interactions must follow this exact flow pattern:
```
User Interaction → Component → Container → Service → API → Store → Component Update
                     ↓
                 Validation → Middleware → State Management → UI Re-render
```

## 1. Component Layer Rules

### 1.1 Component Structure and Hierarchy
- **MUST** follow Atomic Design principles: Atoms → Molecules → Organisms → Templates → Pages
- **MUST** use functional components with React hooks
- **MUST** implement proper component composition patterns
- **MUST** use Shadcn/ui components as the base for all UI elements

### 1.2 Component Implementation
```typescript
// ✅ Correct component pattern
interface ProductCardProps {
  product: Product;
  onAddToCart: (productId: string) => void;
  isLoading?: boolean;
}

export const ProductCard: React.FC<ProductCardProps> = ({ 
  product, 
  onAddToCart, 
  isLoading = false 
}) => {
  return (
    <Card className="group relative overflow-hidden transition-all duration-300 hover:shadow-lg">
      <div className="relative overflow-hidden">
        <ProductImage 
          src={product.imageUrl} 
          alt={product.name}
          className="transition-transform duration-300 group-hover:scale-110"
        />
      </div>
      <CardContent className="p-4">
        <ProductDetails product={product} />
        <Button 
          onClick={() => onAddToCart(product.id)}
          disabled={isLoading}
          className="w-full mt-4"
        >
          {isLoading ? "Adding..." : "Add to Cart"}
        </Button>
      </CardContent>
    </Card>
  );
};
```

### 1.3 Image Zoom Implementation
- **MUST** implement image zoom on hover for all product images
- **MUST** use smooth transitions and modern CSS transforms
- **MUST** maintain aspect ratios during zoom

```typescript
// ✅ Required image zoom component
export const ProductImage: React.FC<ProductImageProps> = ({ src, alt, className }) => {
  return (
    <div className="relative overflow-hidden rounded-lg group">
      <img
        src={src}
        alt={alt}
        className={cn(
          "w-full h-full object-cover transition-transform duration-500 ease-out",
          "group-hover:scale-125 cursor-zoom-in",
          className
        )}
        loading="lazy"
      />
      <div className="absolute inset-0 bg-black/0 group-hover:bg-black/10 transition-colors duration-300" />
    </div>
  );
};
```

### 1.4 Shadcn/ui Integration
- **MUST** use Shadcn/ui components for all UI elements
- **MUST** extend Shadcn components when custom functionality is needed
- **MUST** maintain consistent design system through Shadcn theming

```typescript
// ✅ Required Shadcn component usage
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Badge } from "@/components/ui/badge";
import { Skeleton } from "@/components/ui/skeleton";
```

## 2. Container/Page Layer Rules

### 2.1 Container Responsibilities
- **MUST** orchestrate multiple components
- **MUST** handle page-level state management
- **MUST** coordinate API calls and data fetching
- **MUST** implement proper loading and error states

### 2.2 Page Container Pattern
```typescript
// ✅ Correct container pattern
export const ProductListingPage: React.FC = () => {
  const [products, setProducts] = useState<Product[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
            placeholder="Enter your email"
            className="focus:ring-2 focus:ring-primary"
          />
        </div>
        <Button 
          type="submit" 
          className="w-full bg-gradient-to-r from-primary to-primary/90 hover:from-primary/90 hover:to-primary"
        >
          Complete Purchase
        </Button>
      </CardContent>
    </Card>
  );
};
```

## 2. Container/Page Layer Rules (Next.js)

### 2.1 Page vs Component Separation
- **MUST** use `/pages` or `/app` directory only for routing
- **MUST** keep pages minimal - only routing, layout, and data fetching
- **MUST** delegate UI logic to components in `/components` directory
- **MUST** use containers in `/containers` for complex state orchestration

### 2.2 Page Structure
```typescript
// ✅ Correct page structure (/pages/products/[id].tsx)
interface ProductPageProps {
  productId: string;
}

const ProductPage: NextPage<ProductPageProps> = ({ productId }) => {
  return (
    <MainLayout>
      <SEOHead 
        title={`Product Details - ${productId}`}
        description="View detailed product information"
      />
      <ProductDetailContainer productId={productId} />
    </MainLayout>
  );
};

export const getServerSideProps: GetServerSideProps = async ({ params }) => {
  return {
    props: {
      productId: params?.id as string,
    },
  };
};

export default ProductPage;
```

### 2.3 Container Pattern
```typescript
// ✅ Container component (/containers/ProductDetailContainer.tsx)
interface ProductDetailContainerProps {
  productId: string;
}

export const ProductDetailContainer: React.FC<ProductDetailContainerProps> = ({ productId }) => {
  const { data: product, isLoading, error } = useProduct(productId);
  const { addToCart, isAddingToCart } = useCart();
  const { addToWishlist } = useWishlist();

  const handleAddToCart = useCallback(async (productId: string, quantity: number) => {
    await addToCart({ productId, quantity });
    toast.success('Added to cart successfully!');
  }, [addToCart]);

  if (error) return <ErrorDisplay error={error} />;

  return (
    <div className="container mx-auto px-4 py-8">
      <ProductDetail
        product={product}
        onAddToCart={handleAddToCart}
        onAddToWishlist={addToWishlist}
        isLoading={isLoading}
        isAddingToCart={isAddingToCart}
      />
    </div>
  );
};
```

## 3. Service Layer Rules

### 3.1 Service Implementation
- **MUST** contain all business logic and data transformation
- **MUST** handle API calls and error handling
- **MUST** provide clean interfaces for components
- **MUST** implement proper caching strategies

### 3.2 Service Structure
```typescript
// ✅ Service layer pattern
export class ProductService {
  private apiClient: ApiClient;
  private cache: Map<string, Product> = new Map();

  constructor(apiClient: ApiClient) {
    this.apiClient = apiClient;
  }

  async getProduct(id: string): Promise<Product> {
    // Check cache first
    const cached = this.cache.get(id);
    if (cached && this.isCacheValid(cached)) {
      return cached;
    }

    try {
      const response = await this.apiClient.get<ProductResponse>(`/products/${id}`);
      const product = this.transformProductData(response.data);
      
      // Cache the result
      this.cache.set(id, product);
      
      return product;
    } catch (error) {
      throw new ProductNotFoundError(`Product with ID ${id} not found`);
    }
  }

  private transformProductData(data: ProductResponse): Product {
    return {
      id: data._id,
      name: data.name,
      price: Number(data.price),
      imageUrl: data.images?.[0]?.url || '/placeholder-image.jpg',
      category: data.category,
      inStock: data.inventory > 0,
      rating: data.reviews?.averageRating || 0,
      reviewCount: data.reviews?.count || 0
    };
  }
}
```

## 4. API Layer Rules

### 4.1 API Client Implementation
- **MUST** use a centralized API client with interceptors
- **MUST** implement proper error handling and retry logic
- **MUST** handle authentication tokens automatically
- **MUST** provide type-safe API calls

### 4.2 API Client Structure
```typescript
// ✅ API client pattern
export class ApiClient {
  private client: AxiosInstance;

  constructor(baseURL: string) {
    this.client = axios.create({
      baseURL,
      timeout: 10000,
    });

    this.setupInterceptors();
  }

  private setupInterceptors(): void {
    // Request interceptor
    this.client.interceptors.request.use(
      (config) => {
        const token = getAuthToken();
        if (token) {
          config.headers.Authorization = `Bearer ${token}`;
        }
        return config;
      },
      (error) => Promise.reject(error)
    );

    // Response interceptor
    this.client.interceptors.response.use(
      (response) => response,
      async (error) => {
        if (error.response?.status === 401) {
          await handleTokenRefresh();
          return this.client.request(error.config);
        }
        return Promise.reject(new ApiError(error));
      }
    );
  }

  async get<T>(url: string, config?: AxiosRequestConfig): Promise<ApiResponse<T>> {
    const response = await this.client.get<T>(url, config);
    return { data: response.data, status: response.status };
  }

  async post<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<ApiResponse<T>> {
    const response = await this.client.post<T>(url, data, config);
    return { data: response.data, status: response.status };
  }
}
```

## 5. Store/State Management Rules

### 5.1 State Management Implementation
- **MUST** use Zustand or Redux Toolkit for global state
- **MUST** update store when API data changes
- **MUST** implement optimistic updates where appropriate
- **MUST** maintain normalized state structure

### 5.2 Store Structure (Zustand)
```typescript
// ✅ Store implementation
interface CartState {
  items: CartItem[];
  total: number;
  isLoading: boolean;
  error: string | null;
  
  // Actions
  addItem: (item: CartItem) => Promise<void>;
  removeItem: (itemId: string) => Promise<void>;
  updateQuantity: (itemId: string, quantity: number) => Promise<void>;
  clearCart: () => void;
  loadCart: () => Promise<void>;
}

export const useCartStore = create<CartState>((set, get) => ({
  items: [],
  total: 0,
  isLoading: false,
  error: null,

  addItem: async (item: CartItem) => {
    set({ isLoading: true, error: null });
    
    try {
      // Optimistic update
      const currentItems = get().items;
      const existingItem = currentItems.find(i => i.productId === item.productId);
      
      let newItems: CartItem[];
      if (existingItem) {
        newItems = currentItems.map(i => 
          i.productId === item.productId 
            ? { ...i, quantity: i.quantity + item.quantity }
            : i
        );
      } else {
        newItems = [...currentItems, item];
      }

      set({ items: newItems, total: calculateTotal(newItems) });

      // API call
      await cartService.addItem(item);
      
      set({ isLoading: false });
    } catch (error) {
      // Revert optimistic update
      set({ items: get().items, error: error.message, isLoading: false });
      throw error;
    }
  },

  removeItem: async (itemId: string) => {
    const currentItems = get().items;
    const newItems = currentItems.filter(item => item.id !== itemId);
    
    // Optimistic update
    set({ items: newItems, total: calculateTotal(newItems) });

    try {
      await cartService.removeItem(itemId);
    } catch (error) {
      // Revert on error
      set({ items: currentItems });
      throw error;
    }
  }
}));
```

## 6. Data Model Rules

### 6.1 Model Hierarchy and Relationships
- **MUST** define base models that other models extend
- **MUST** maintain consistent relationships like database models
- **MUST** implement proper type inheritance

### 6.2 Model Structure
```typescript
// ✅ Base model pattern
interface BaseEntity {
  id: string;
  createdAt: Date;
  updatedAt: Date;
}

interface BaseProduct extends BaseEntity {
  name: string;
  description: string;
  price: number;
  imageUrl: string;
  category: Category;
}

// Extended models
interface Product extends BaseProduct {
  inventory: number;
  rating: number;
  reviewCount: number;
  variants: ProductVariant[];
  relatedProducts: Product[];
}

interface CartItem extends BaseEntity {
  productId: string;
  product: Pick<Product, 'name' | 'price' | 'imageUrl'>; // Partial product data
  quantity: number;
  selectedVariant?: ProductVariant;
}

interface Order extends BaseEntity {
  userId: string;
  items: OrderItem[];
  totalAmount: number;
  status: OrderStatus;
  shippingAddress: Address;
  paymentMethod: PaymentMethod;
}

interface OrderItem {
  productId: string;
  product: Pick<Product, 'name' | 'imageUrl'>; // Minimal product data
  quantity: number;
  unitPrice: number;
  totalPrice: number;
}

// Category hierarchy
interface Category extends BaseEntity {
  name: string;
  slug: string;
  parentCategory?: Category;
  childCategories: Category[];
  productCount: number;
}
```

### 6.3 Data Transformation
- **MUST** transform API responses to consistent frontend models
- **MUST** handle missing or null data gracefully
- **MUST** validate data at model boundaries

## 7. Validation Rules

### 7.1 Input Validation
- **MUST** validate all user inputs before processing
- **MUST** provide real-time validation feedback
- **MUST** use schema validation libraries (Zod, Yup)

### 7.2 Form Validation Pattern
```typescript
// ✅ Validation implementation
import { z } from 'zod';

const checkoutSchema = z.object({
  email: z.string().email('Please enter a valid email'),
  firstName: z.string().min(2, 'First name must be at least 2 characters'),
  lastName: z.string().min(2, 'Last name must be at least 2 characters'),
  address: z.object({
    street: z.string().min(5, 'Please enter a valid street address'),
    city: z.string().min(2, 'Please enter a valid city'),
    zipCode: z.string().regex(/^\d{5}(-\d{4})?$/, 'Please enter a valid ZIP code'),
    country: z.string().min(2, 'Please select a country')
  }),
  paymentMethod: z.enum(['credit_card', 'paypal', 'apple_pay'])
});

type CheckoutFormData = z.infer<typeof checkoutSchema>;

export const CheckoutForm: React.FC = () => {
  const { register, handleSubmit, formState: { errors, isValid } } = useForm<CheckoutFormData>({
    resolver: zodResolver(checkoutSchema),
    mode: 'onChange' // Real-time validation
  });

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
      <div>
        <Label htmlFor="email">Email *</Label>
        <Input
          {...register('email')}
          type="email"
          className={errors.email ? 'border-red-500 focus:ring-red-500' : ''}
        />
        {errors.email && (
          <p className="text-sm text-red-600 mt-1">{errors.email.message}</p>
        )}
      </div>
      
      <Button 
        type="submit" 
        disabled={!isValid}
        className="w-full"
      >
        Complete Purchase
      </Button>
    </form>
  );
};
```

## 8. Data Binding and Hydration Rules

### 8.1 Server-Side Rendering (SSR) Hydration
- **MUST** implement proper SSR hydration for SEO and performance
- **MUST** handle hydration mismatches gracefully
- **MUST** prefetch critical data on server

### 8.2 Hydration Implementation
```typescript
// ✅ SSR hydration pattern
interface ProductPageProps {
  initialProduct: Product;
  relatedProducts: Product[];
}

export const getServerSideProps: GetServerSideProps<ProductPageProps> = async ({ params }) => {
  const productId = params?.id as string;

  try {
    const [product, relatedProducts] = await Promise.all([
      productService.getProduct(productId),
      productService.getRelatedProducts(productId, 4)
    ]);

    return {
      props: {
        initialProduct: product,
        relatedProducts
      }
    };
  } catch (error) {
    return { notFound: true };
  }
};

// Component with hydration
export const ProductDetailContainer: React.FC<ProductPageProps> = ({ 
  initialProduct, 
  relatedProducts 
}) => {
  // Initialize store with server data
  const { data: product } = useProduct(initialProduct.id, {
    initialData: initialProduct, // Prevent loading state on hydration
    staleTime: 5 * 60 * 1000 // 5 minutes
  });

  const { data: related } = useRelatedProducts(initialProduct.id, {
    initialData: relatedProducts
  });

  return (
    <div>
      <ProductDetail product={product} />
      <RelatedProducts products={related} />
    </div>
  );
};
```

## 9. React Best Practices Rules

### 9.1 Routing (Next.js)
- **MUST** use Next.js App Router for new projects
- **MUST** implement proper loading states for route transitions
- **MUST** use dynamic imports for code splitting
- **MUST** implement proper error boundaries

### 9.2 Data Fetching
- **MUST** use React Query/TanStack Query for server state
- **MUST** implement proper caching strategies
- **MUST** handle loading and error states consistently

```typescript
// ✅ Data fetching pattern
export const useProducts = (filters: ProductFilters) => {
  return useQuery({
    queryKey: ['products', filters],
    queryFn: () => productService.getProducts(filters),
    staleTime: 5 * 60 * 1000, // 5 minutes
    cacheTime: 10 * 60 * 1000, // 10 minutes
    retry: 3,
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
    onError: (error) => {
      toast.error('Failed to load products');
      logError('PRODUCTS_FETCH_ERROR', error);
    }
  });
};

// Usage in component
export const ProductList: React.FC<ProductListProps> = ({ filters }) => {
  const { data: products, isLoading, error, refetch } = useProducts(filters);

  if (error) {
    return (
      <ErrorState 
        message="Failed to load products" 
        onRetry={refetch}
      />
    );
  }

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
      {isLoading ? (
        <ProductSkeleton count={6} />
      ) : (
        products?.map(product => (
          <ProductCard 
            key={product.id} 
            product={product}
            onAddToCart={handleAddToCart}
          />
        ))
      )}
    </div>
  );
};
```

## 10. E-commerce UX Rules

### 10.1 Product Display Requirements
- **MUST** implement image zoom on hover for all product images
- **MUST** provide multiple product image views (gallery)
- **MUST** show stock status and availability
- **MUST** display pricing clearly with discounts highlighted

### 10.2 Shopping Cart UX
- **MUST** provide visual feedback for add to cart actions
- **MUST** show cart item count in header/navigation
- **MUST** implement cart persistence across sessions
- **MUST** provide easy quantity updates and removal

### 10.3 Checkout Experience
- **MUST** implement single-page checkout flow
- **MUST** show progress indicators for multi-step processes
- **MUST** provide guest checkout option
- **MUST** display order summary throughout checkout

## 11. Modern Aesthetic Rules

### 11.1 Design System
- **MUST** use consistent spacing scale (4, 8, 16, 24, 32px)
- **MUST** implement proper color contrast ratios (WCAG AA)
- **MUST** use modern typography scale with proper line heights
- **MUST** implement smooth animations and transitions

### 11.2 Visual Design Patterns
```typescript
// ✅ Modern design system
const designTokens = {
  spacing: {
    xs: '0.25rem', // 4px
    sm: '0.5rem',  // 8px
    md: '1rem',    // 16px
    lg: '1.5rem',  // 24px
    xl: '2rem',    // 32px
  },
  borderRadius: {
    sm: '0.25rem',
    md: '0.5rem',
    lg: '1rem',
    full: '9999px'
  },
  shadows: {
    sm: '0 1px 2px 0 rgb(0 0 0 / 0.05)',
    md: '0 4px 6px -1px rgb(0 0 0 / 0.1)',
    lg: '0 10px 15px -3px rgb(0 0 0 / 0.1)',
  },
  animations: {
    fast: '150ms ease-in-out',
    normal: '300ms ease-in-out',
    slow: '500ms ease-in-out'
  }
};

// Modern card component
export const ModernProductCard: React.FC<ProductCardProps> = ({ product }) => {
  return (
    <Card className="group overflow-hidden border-0 shadow-md hover:shadow-xl transition-all duration-300 bg-white/80 backdrop-blur-sm">
      <div className="relative overflow-hidden">
        <ProductImage 
          src={product.imageUrl}
          alt={product.name}
          className="aspect-square object-cover transition-transform duration-500 group-hover:scale-105"
        />
        <div className="absolute inset-0 bg-gradient-to-t from-black/20 to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-300" />
        <Button
          size="sm"
          className="absolute top-3 right-3 opacity-0 group-hover:opacity-100 transition-all duration-300 transform translate-y-2 group-hover:translate-y-0"
          variant="secondary"
    console.log(`[USER_ACTION] ${action}`, data);
    // Send to analytics service for user behavior tracking
  }
}

// Usage in components
const handleAddToCart = useCallback(async (productId: string) => {
  Logger.userAction('ADD_TO_CART', { productId });
  
  try {
    await cartStore.addItem(productId, 1);
    Logger.info('Product added to cart successfully', { productId });
  } catch (error) {
    Logger.error('Failed to add product to cart', error as Error, { productId });
    toast.error('Failed to add product to cart');
  }
}, [cartStore]);
```

## 13. Testing Rules

### 13.1 Component Testing
- **MUST** write unit tests for all components using React Testing Library
- **MUST** test user interactions and state changes
- **MUST** test error states and edge cases
- **MUST** maintain minimum 80% test coverage

### 13.2 Integration Testing
- **MUST** test complete user flows (browse → add to cart → checkout)
- **MUST** test API integration with mock services
- **MUST** test routing and navigation

## 14. Comment and Documentation Rules

### 14.1 Meaningful Comments Only
- **MUST** comment complex business logic and calculations
- **MUST** document component props and their usage
- **MUST** explain non-obvious UI/UX decisions
- **MUST NOT** comment obvious React patterns or simple UI logic

### 14.2 Comment Examples
```typescript
// ✅ Good comments
/**
 * ProductCard component displays product information with optimized image loading
 * and hover effects for enhanced user experience in e-commerce browsing
 */
export const ProductCard: React.FC<ProductCardProps> = ({ product }) => {
  // Calculate discount percentage for display (business logic)
  const discountPercent = useMemo(() => {
    if (product.originalPrice && product.price < product.originalPrice) {
      return Math.round(((product.originalPrice - product.price) / product.originalPrice) * 100);
    }
    return 0;
  }, [product.price, product.originalPrice]);

  // Implement optimistic UI update before API call to improve perceived performance
  const handleQuickAdd = useCallback(async (productId: string) => {
    // ... implementation
  }, []);
};
```

---

## Enforcement
- **ALL** rules are mandatory and must be followed
- **CODE REVIEWS** must verify adherence to architecture patterns
- **AUTOMATED TESTING** must cover all components and user flows
- **PERFORMANCE AUDITS** must be conducted regularly
- **ACCESSIBILITY TESTING** must ensure WCAG compliance
- **USER EXPERIENCE TESTING** must validate e-commerce conversion flows

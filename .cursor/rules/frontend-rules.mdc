---
description: Pradeep Opticals - Frontend code guidelines
globs: Code Guidelines for the fronted
alwaysApply: true
---
# Frontend Architecture Ruleset

## Architecture Flow
All user interactions must follow this exact flow pattern:
```
User Interaction → Component → Container → Service → API → Store → Component Update
                     ↓
                 Validation → Middleware → State Management → UI Re-render
```

## 1. Component Layer Rules

### 1.1 Component Structure and Hierarchy
- **MUST** follow Atomic Design principles: Atoms → Molecules → Organisms → Templates → Pages
- **MUST** use functional components with React hooks
- **MUST** implement proper component composition patterns
- **MUST** use Shadcn/ui components as the base for all UI elements

### 1.2 Component Implementation
```typescript
// ✅ Correct component pattern
interface ProductCardProps {
  product: Product;
  onAddToCart: (productId: string) => void;
  isLoading?: boolean;
}

export const ProductCard: React.FC<ProductCardProps> = ({ 
  product, 
  onAddToCart, 
  isLoading = false 
}) => {
  return (
    <Card className="group relative overflow-hidden transition-all duration-300 hover:shadow-lg">
      <div className="relative overflow-hidden">
        <ProductImage 
          src={product.imageUrl} 
          alt={product.name}
          className="transition-transform duration-300 group-hover:scale-110"
        />
      </div>
      <CardContent className="p-4">
        <ProductDetails product={product} />
        <Button 
          onClick={() => onAddToCart(product.id)}
          disabled={isLoading}
          className="w-full mt-4"
        >
          {isLoading ? "Adding..." : "Add to Cart"}
        </Button>
      </CardContent>
    </Card>
  );
};
```

### 1.3 Image Zoom Implementation
- **MUST** implement image zoom on hover for all product images
- **MUST** use smooth transitions and modern CSS transforms
- **MUST** maintain aspect ratios during zoom

```typescript
// ✅ Required image zoom component
export const ProductImage: React.FC<ProductImageProps> = ({ src, alt, className }) => {
  return (
    <div className="relative overflow-hidden rounded-lg group">
      <img
        src={src}
        alt={alt}
        className={cn(
          "w-full h-full object-cover transition-transform duration-500 ease-out",
          "group-hover:scale-125 cursor-zoom-in",
          className
        )}
        loading="lazy"
      />
      <div className="absolute inset-0 bg-black/0 group-hover:bg-black/10 transition-colors duration-300" />
    </div>
  );
};
```

### 1.4 Shadcn/ui Integration
- **MUST** use Shadcn/ui components for all UI elements
- **MUST** extend Shadcn components when custom functionality is needed
- **MUST** maintain consistent design system through Shadcn theming

```typescript
// ✅ Required Shadcn component usage
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Badge } from "@/components/ui/badge";
import { Skeleton } from "@/components/ui/skeleton";
```

## 2. Container/Page Layer Rules

### 2.1 Container Responsibilities
- **MUST** orchestrate multiple components
- **MUST** handle page-level state management
- **MUST** coordinate API calls and data fetching
- **MUST** implement proper loading and error states

### 2.2 Page Container Pattern
```typescript
// ✅ Correct container pattern
export const ProductListingPage: React.FC = () => {
  const [products, setProducts] = useState<Product[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [filters, setFilters] = useState<ProductFilters>({});

  const { addToCart } = useCart();
  const { user } = useAuth();

  useEffect(() => {
    const fetchProducts = async () => {
      try {
        setLoading(true);
        const response = await productService.getProducts(filters);
        setProducts(response.data);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to fetch products');
      } finally {
        setLoading(false);
      }
    };

    fetchProducts();
  }, [filters]);

  const handleAddToCart = useCallback(async (productId: string) => {
    try {
      await addToCart(productId, 1);
      toast.success('Product added to cart');
    } catch (err) {
      toast.error('Failed to add product to cart');
    }
  }, [addToCart]);

  if (loading) return <ProductListingSkeleton />;
  if (error) return <ErrorBoundary error={error} />;

  return (
    <div className="container mx-auto px-4 py-8">
      <ProductFilters onFiltersChange={setFilters} />
      <ProductGrid 
        products={products}
        onAddToCart={handleAddToCart}
      />
    </div>
  );
};
```

### 2.3 Loading and Error States
- **MUST** implement skeleton loading states using Shadcn Skeleton
- **MUST** provide meaningful error messages and recovery options
- **MUST** handle empty states with proper UI feedback

## 3. Routing Layer Rules

### 3.1 React Router Implementation
- **MUST** use React Router v6+ with proper route structure
- **MUST** implement nested routes for complex layouts
- **MUST** use proper route guards for authentication
- **MUST** implement lazy loading for route components

### 3.2 Router Configuration
```typescript
// ✅ Required router structure
const router = createBrowserRouter([
  {
    path: "/",
    element: <RootLayout />,
    errorElement: <ErrorPage />,
    children: [
      {
        index: true,
        element: <HomePage />,
      },
      {
        path: "products",
        element: <ProductLayout />,
        children: [
          {
            index: true,
            element: <ProductListingPage />,
          },
          {
            path: ":productId",
            element: <ProductDetailPage />,
            loader: productLoader,
          },
        ],
      },
      {
        path: "cart",
        element: <ProtectedRoute><CartPage /></ProtectedRoute>,
      },
      {
        path: "checkout",
        element: <ProtectedRoute><CheckoutPage /></ProtectedRoute>,
      },
    ],
  },
]);
```

### 3.2 Protected Routes
```typescript
// ✅ Required protected route implementation
export const ProtectedRoute: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const { user, loading } = useAuth();
  const location = useLocation();

  if (loading) return <LoadingSpinner />;
  
  if (!user) {
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  return <>{children}</>;
};
```

### 3.3 Route-based Code Splitting
- **MUST** implement lazy loading for all route components
- **MUST** use React.Suspense with proper fallback components

```typescript
// ✅ Required lazy loading pattern
const ProductDetailPage = lazy(() => import('@/pages/ProductDetailPage'));
const CartPage = lazy(() => import('@/pages/CartPage'));
const CheckoutPage = lazy(() => import('@/pages/CheckoutPage'));
```

## 4. State Management Layer Rules

### 4.1 Global State Management
- **MUST** use Zustand or Redux Toolkit for global state
- **MUST** separate state by domain (auth, cart, products, orders)
- **MUST** implement proper state persistence for cart and user preferences
- **MUST** update state immediately when API operations succeed

### 4.2 Zustand Store Pattern
```typescript
// ✅ Required Zustand store structure
interface CartState {
  items: CartItem[];
  total: number;
  isLoading: boolean;
  addItem: (productId: string, quantity: number) => Promise<void>;
  removeItem: (itemId: string) => Promise<void>;
  updateQuantity: (itemId: string, quantity: number) => Promise<void>;
  clearCart: () => Promise<void>;
  syncWithServer: () => Promise<void>;
}

export const useCartStore = create<CartState>((set, get) => ({
  items: [],
  total: 0,
  isLoading: false,

  addItem: async (productId: string, quantity: number) => {
    set({ isLoading: true });
    try {
      const response = await cartService.addItem(productId, quantity);
      set({ 
        items: response.items, 
        total: response.total,
        isLoading: false 
      });
    } catch (error) {
      set({ isLoading: false });
      throw error;
    }
  },

  // ... other actions
}));
```

### 4.3 State Synchronization
- **MUST** sync state with server after successful API operations
- **MUST** implement optimistic updates with rollback on failure
- **MUST** handle concurrent state updates properly

### 4.4 Local State Management
- **MUST** use useState for component-level state
- **MUST** use useReducer for complex local state logic
- **MUST** implement custom hooks for reusable state logic

## 5. Service Layer Rules

### 5.1 Service Structure
- **MUST** create dedicated service classes for each domain
- **MUST** implement proper error handling and retries
- **MUST** handle loading states and provide progress feedback
- **MUST** implement proper caching strategies

### 5.2 Service Implementation
```typescript
// ✅ Required service pattern
export class ProductService {
  constructor(private apiClient: ApiClient) {}

  async getProducts(filters: ProductFilters): Promise<ApiResponse<Product[]>> {
    try {
      const response = await this.apiClient.get<Product[]>('/products', {
        params: filters,
      });
      
      return response.data;
    } catch (error) {
      this.handleError(error, 'Failed to fetch products');
      throw error;
    }
  }

  async getProductById(id: string): Promise<ApiResponse<Product>> {
    try {
      const response = await this.apiClient.get<Product>(`/products/${id}`);
      return response.data;
    } catch (error) {
      this.handleError(error, `Failed to fetch product ${id}`);
      throw error;
    }
  }

  private handleError(error: unknown, context: string): void {
    console.error(`${context}:`, error);
    // Additional error logging/reporting logic
  }
}

export const productService = new ProductService(apiClient);
```

### 5.3 Caching Strategy
- **MUST** implement proper caching for frequently accessed data
- **MUST** invalidate cache when related data changes
- **MUST** use React Query or SWR for server state management

## 6. API Layer Rules

### 6.1 API Client Configuration
- **MUST** use Axios or Fetch with proper interceptors
- **MUST** implement request/response transformations
- **MUST** handle authentication token management
- **MUST** implement proper error handling and retries

### 6.2 API Client Implementation
```typescript
// ✅ Required API client pattern
class ApiClient {
  private client: AxiosInstance;

  constructor(baseURL: string) {
    this.client = axios.create({
      baseURL,
      timeout: 10000,
      headers: {
        'Content-Type': 'application/json',
      },
    });

    this.setupInterceptors();
  }

  private setupInterceptors(): void {
    // Request interceptor for auth token
    this.client.interceptors.request.use((config) => {
      const token = tokenStorage.getToken();
      if (token) {
        config.headers.Authorization = `Bearer ${token}`;
      }
      return config;
    });

    // Response interceptor for error handling
    this.client.interceptors.response.use(
      (response) => response,
      async (error) => {
        if (error.response?.status === 401) {
          await authService.logout();
          window.location.href = '/login';
        }
        return Promise.reject(error);
      }
    );
  }

  async get<T>(url: string, config?: AxiosRequestConfig): Promise<AxiosResponse<T>> {
    return this.client.get<T>(url, config);
  }

  async post<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<AxiosResponse<T>> {
    return this.client.post<T>(url, data, config);
  }

  // ... other HTTP methods
}

export const apiClient = new ApiClient(process.env.REACT_APP_API_URL!);
```

### 6.3 Request/Response Types
- **MUST** define TypeScript interfaces for all API requests/responses
- **MUST** use consistent API response format matching backend
- **MUST** implement proper error response handling

## 7. Data Models and Type System Rules

### 7.1 Model Hierarchy and Relationships
- **MUST** create base models that other models extend
- **MUST** implement proper model relationships similar to database design
- **MUST** use consistent naming conventions across all models

### 7.2 Model Implementation
```typescript
// ✅ Required model hierarchy
interface BaseModel {
  id: string;
  createdAt: Date;
  updatedAt: Date;
}

interface User extends BaseModel {
  email: string;
  name: string;
  role: UserRole;
  profile: UserProfile;
  addresses: Address[];
  orders: Order[];
}

interface Product extends BaseModel {
  name: string;
  description: string;
  price: number;
  currency: string;
  images: ProductImage[];
  category: Category;
  variants: ProductVariant[];
  inventory: InventoryInfo;
  ratings: ProductRating[];
  averageRating: number;
}

interface Order extends BaseModel {
  userId: string;
  user: User; // Populated reference
  items: OrderItem[];
  total: number;
  status: OrderStatus;
  shippingAddress: Address;
  billingAddress: Address;
  paymentInfo: PaymentInfo;
}

// DTO types for API operations
interface CreateOrderDto {
  items: CreateOrderItemDto[];
  shippingAddressId: string;
  billingAddressId: string;
  paymentMethodId: string;
}
```

### 7.3 Type Safety Rules
- **MUST** use strict TypeScript configuration
- **MUST NOT** use `any` type under any circumstances
- **MUST** use union types for enums and status values
- **MUST** implement proper type guards for runtime type checking

### 7.4 Data Transformation
```typescript
// ✅ Required data transformation utilities
export class ModelTransformer {
  static productFromApi(apiProduct: ApiProduct): Product {
    return {
      ...apiProduct,
      createdAt: new Date(apiProduct.createdAt),
      updatedAt: new Date(apiProduct.updatedAt),
      price: Number(apiProduct.price),
      averageRating: Number(apiProduct.averageRating),
    };
  }

  static productToApi(product: Product): ApiProductRequest {
    return {
      name: product.name,
      description: product.description,
      price: product.price.toString(),
      categoryId: product.category.id,
    };
  }
}
```

## 8. Validation Layer Rules

### 8.1 Client-side Validation
- **MUST** validate all user inputs before sending to API
- **MUST** use Zod or Yup for schema validation
- **MUST** provide real-time validation feedback
- **MUST** implement proper form validation with error states

### 8.2 Form Validation Implementation
```typescript
// ✅ Required form validation pattern
const checkoutSchema = z.object({
  shippingAddress: z.object({
    street: z.string().min(5, "Street address must be at least 5 characters"),
    city: z.string().min(2, "City is required"),
    postalCode: z.string().regex(/^\d{5}(-\d{4})?$/, "Invalid postal code"),
    country: z.string().min(2, "Country is required"),
  }),
  paymentMethod: z.object({
    cardNumber: z.string().regex(/^\d{16}$/, "Card number must be 16 digits"),
    expiryMonth: z.number().min(1).max(12),
    expiryYear: z.number().min(new Date().getFullYear()),
    cvv: z.string().regex(/^\d{3,4}$/, "CVV must be 3 or 4 digits"),
  }),
});

type CheckoutFormData = z.infer<typeof checkoutSchema>;

export const CheckoutForm: React.FC = () => {
  const { control, handleSubmit, formState: { errors, isSubmitting } } = useForm<CheckoutFormData>({
    resolver: zodResolver(checkoutSchema),
  });

  const onSubmit = async (data: CheckoutFormData) => {
    try {
      await orderService.createOrder(data);
      router.push('/order-confirmation');
    } catch (error) {
      toast.error('Failed to process order');
    }
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
      <div className="space-y-4">
        <Controller
          name="shippingAddress.street"
          control={control}
          render={({ field }) => (
            <div>
              <Input
                {...field}
                placeholder="Street Address"
                className={errors.shippingAddress?.street ? "border-red-500" : ""}
              />
              {errors.shippingAddress?.street && (
                <p className="text-red-500 text-sm mt-1">
                  {errors.shippingAddress.street.message}
                </p>
              )}
            </div>
          )}
        />
      </div>
      
      <Button type="submit" disabled={isSubmitting} className="w-full">
        {isSubmitting ? "Processing..." : "Place Order"}
      </Button>
    </form>
  );
};
```

## 9. UI/UX and Design Rules

### 9.1 Modern Aesthetic Requirements
- **MUST** use modern design principles with clean, minimal interfaces
- **MUST** implement consistent spacing using Tailwind's spacing scale
- **MUST** use proper typography hierarchy with readable font sizes
- **MUST** implement dark/light theme support

### 9.2 E-commerce UX Best Practices
- **MUST** provide clear product information and pricing
- **MUST** implement intuitive navigation and search functionality
- **MUST** show loading states during all async operations
- **MUST** provide clear calls-to-action throughout the shopping flow
- **MUST** implement proper error states with recovery options

### 9.3 Image and Media Handling
```typescript
// ✅ Required image optimization and zoom
export const ProductImageGallery: React.FC<ProductImageGalleryProps> = ({ images }) => {
  const [selectedImage, setSelectedImage] = useState(0);

  return (
    <div className="space-y-4">
      <div className="relative aspect-square overflow-hidden rounded-lg bg-gray-100">
        <img
          src={images[selectedImage].url}
          alt={images[selectedImage].alt}
          className="h-full w-full object-cover transition-transform duration-500 hover:scale-110 cursor-zoom-in"
        />
      </div>
      
      <div className="flex space-x-2 overflow-x-auto">
        {images.map((image, index) => (
          <button
            key={image.id}
            onClick={() => setSelectedImage(index)}
            className={cn(
              "flex-shrink-0 aspect-square w-16 h-16 rounded-md overflow-hidden border-2 transition-colors",
              selectedImage === index ? "border-primary" : "border-transparent"
            )}
          >
            <img
              src={image.thumbnailUrl}
              alt={image.alt}
              className="w-full h-full object-cover hover:scale-105 transition-transform"
            />
          </button>
        ))}
      </div>
    </div>
  );
};
```

### 9.4 Responsive Design
- **MUST** implement mobile-first responsive design
- **MUST** test on all screen sizes from mobile to desktop
- **MUST** use Tailwind's responsive prefixes consistently
- **MUST** ensure touch-friendly interface elements on mobile

## 10. Performance and Optimization Rules

### 10.1 Component Optimization
- **MUST** use React.memo for expensive components
- **MUST** implement proper useCallback and useMemo usage
- **MUST** avoid unnecessary re-renders through proper dependency arrays

### 10.2 Image and Asset Optimization
- **MUST** implement lazy loading for all images
- **MUST** use proper image formats (WebP, AVIF) with fallbacks
- **MUST** implement progressive image loading with placeholders

### 10.3 Code Splitting and Bundle Optimization
- **MUST** implement route-based code splitting
- **MUST** use dynamic imports for heavy libraries
- **MUST** optimize bundle size and remove unused code

## 11. Data Binding and Hydration Rules

### 11.1 Server-Side Rendering (SSR)
- **MUST** implement proper SSR for SEO-critical pages
- **MUST** handle hydration mismatches gracefully
- **MUST** use proper data fetching patterns for SSR

### 11.2 Data Binding Patterns
```typescript
// ✅ Required data binding pattern
export const ProductList: React.FC = () => {
  const { data: products, isLoading, error, refetch } = useQuery({
    queryKey: ['products'],
    queryFn: () => productService.getProducts(),
    staleTime: 5 * 60 * 1000, // 5 minutes
  });

  const cartStore = useCartStore();

  // Auto-sync cart when products data changes
  useEffect(() => {
    if (products) {
      cartStore.syncWithServer();
    }
  }, [products, cartStore]);

  if (isLoading) return <ProductListSkeleton />;
  if (error) return <ErrorBoundary error={error} retry={refetch} />;

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
      {products.map((product) => (
        <ProductCard
          key={product.id}
          product={product}
          onAddToCart={cartStore.addItem}
        />
      ))}
    </div>
  );
};
```

## 12. Error Handling and Logging Rules

### 12.1 Error Boundaries
- **MUST** implement error boundaries at route and component levels
- **MUST** provide user-friendly error messages with recovery options
- **MUST** log errors for debugging and monitoring

### 12.2 Client-side Logging
```typescript
// ✅ Required logging implementation
export class Logger {
  static info(message: string, data?: Record<string, any>): void {
    console.info(`[INFO] ${message}`, data);
    // Send to analytics/monitoring service in production
  }

  static error(message: string, error?: Error, data?: Record<string, any>): void {
    console.error(`[ERROR] ${message}`, error, data);
    // Send to error reporting service in production
  }

  static userAction(action: string, data?: Record<string, any>): void {
    console.log(`[USER_ACTION] ${action}`, data);
    // Send to analytics service for user behavior tracking
  }
}

// Usage in components
const handleAddToCart = useCallback(async (productId: string) => {
  Logger.userAction('ADD_TO_CART', { productId });
  
  try {
    await cartStore.addItem(productId, 1);
    Logger.info('Product added to cart successfully', { productId });
  } catch (error) {
    Logger.error('Failed to add product to cart', error as Error, { productId });
    toast.error('Failed to add product to cart');
  }
}, [cartStore]);
```

## 13. Testing Rules

### 13.1 Component Testing
- **MUST** write unit tests for all components using React Testing Library
- **MUST** test user interactions and state changes
- **MUST** test error states and edge cases
- **MUST** maintain minimum 80% test coverage

### 13.2 Integration Testing
- **MUST** test complete user flows (browse → add to cart → checkout)
- **MUST** test API integration with mock services
- **MUST** test routing and navigation

## 14. Comment and Documentation Rules

### 14.1 Meaningful Comments Only
- **MUST** comment complex business logic and calculations
- **MUST** document component props and their usage
- **MUST** explain non-obvious UI/UX decisions
- **MUST NOT** comment obvious React patterns or simple UI logic

### 14.2 Comment Examples
```typescript
// ✅ Good comments
/**
 * ProductCard component displays product information with optimized image loading
 * and hover effects for enhanced user experience in e-commerce browsing
 */
export const ProductCard: React.FC<ProductCardProps> = ({ product }) => {
  // Calculate discount percentage for display (business logic)
  const discountPercent = useMemo(() => {
    if (product.originalPrice && product.price < product.originalPrice) {
      return Math.round(((product.originalPrice - product.price) / product.originalPrice) * 100);
    }
    return 0;
  }, [product.price, product.originalPrice]);

  // Implement optimistic UI update before API call to improve perceived performance
  const handleQuickAdd = useCallback(async (productId: string) => {
    // ... implementation
  }, []);
};
```

---

## Enforcement
- **ALL** rules are mandatory and must be followed
- **CODE REVIEWS** must verify adherence to architecture patterns
- **AUTOMATED TESTING** must cover all components and user flows
- **PERFORMANCE AUDITS** must be conducted regularly
- **ACCESSIBILITY TESTING** must ensure WCAG compliance
- **USER EXPERIENCE TESTING** must validate e-commerce conversion flows
